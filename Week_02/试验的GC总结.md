### 不同GC和堆内存的总结：

- 串行GC在运行过程中，内存太小（216m）会OOM，不断的增加内存可以减少GC的次数，但是因为内存增大，每次回收的对象更多，每次GC的时间会增加。堆内存设置过少，容易导致出现OOM，默认是本机内存的1/4。
- 并行GC和Serial GC类似，内存设置得太小会频繁触发GC，内存过大虽然减少了GC次数，但是会增加每次GC的时间。
- CMS GC内存设置得太小会频繁触发GC，内存过大虽然减少了GC次数，但是会增加每次GC的时间，内存太小和容易触发“并发失败”，导致退化为串行GC，内存太大当存在大量内存碎片的时候，也会增加延迟

> 最后，GC的堆内存设置并不是越大越好，要结合业务进行考虑，堆内存设置得太小，会导致频繁的GC，最后甚至OOM，但是设置得太大又会增加每次GC的时间，不是堆内存设置得越大越好，太大会导致单次GC时间变长，最后导致吞吐量降低。 特别的对于G1 GC来说需要的堆较大，堆的大小并不是很影响其GC时间。

总体情况: 大内存下,G1>CMS>Parallel>Serial

> 备注：JDK9（不包括9）之前是默认为并行GC， JDK9后默认为G1，这两个GC关注点不同，并行GC主要看中吞吐量，而G1主要是关注暂停时间，但是G1对于大内存的情况下效率很高。最后对于Serial GC 作为最早期的GC 其不管电脑是否是多核，都是串行化，在Stop The World时只有GC线程在工作。


